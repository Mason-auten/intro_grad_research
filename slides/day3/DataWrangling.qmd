---
title: "Introduction"
subtitle: "Introduction to Graduate Research"
format: 
  clean-revealjs:
    echo: true
    scrollable: true
  html-math-method:
    method: mathjax
    url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
author:
  - name: Mason Auten
    email: mason.auten@vanderbilt.edu
    affiliations: Vanderbilt University
  - name: Patrick Buhr
    email: patrick.buhr@vanderbilt.edu
    affiliations: Vanderbilt University
date: today
self-contained: true
---

## Loading in Data

```{r}
#| echo: false
#| message: false
library("tidyverse")

## Only output five tibble rows by default
options(tibble.print_min = 5,
        tibble.max_extra_cols = 3)
```

:::::: columns
::: {.column width="50%"}
1.  Navigate to your working directory.
2.  Download the `congress_data.csv` file and put it there
3.  Set as R's working directory
    -   Windows: `setwd('C:/path/to/directory')`
    -   Mac: `setwd('~/path/to/directory')`
    -   ... or just navigate in RStudio and set it that way
4.  Check that `congress_data <- read_csv("congress_data.csv")` works
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
```{r}
#| echo: false
options(width = 42)
library(tidyverse)
```

```{r}
#| echo: TRUE
congress_data <- read_csv(here::here("inst", "congress_data.csv"))

print(congress_data)
```
:::
::::::

# Manipulating data

## Basics of data manipulation

Use `$` to extract a single column

```{r}
#| echo: false
options(width = 93, max.print = 25)
```

```{r}
congress_data$name
```

Use square brackets `[` `]` to extract individual value(s)

```{r}
congress_data$name[5]     # age of the 5'th row of the data
congress_data$name[1:10]  # first 10 ages in the data
```

## Describing Data

On Tuesday, we learned a variety of options for descriptive statistics.

```{r}
mean(congress_data$seniority, na.rm = TRUE)    # average/mean
median(congress_data$seniority, na.rm = TRUE)  # median
sd(congress_data$seniority, na.rm = TRUE)      # standard deviation
cor(congress_data$seniority, congress_data$les, use = "complete.obs")
```

## Manipulating Data

In your career as a social scientist, you will spend much more time cleaning, merging, and tidying data than actually running analysis.

Fortunately, the `dplyr` package within `tidyverse` gives many options for data manipulation.

We will run through the most popular here.

## `rename()`

`rename()` allows you to rename variables to different names.

Suppose we think that the variable "female" is a bit dated.

```{r}
congress_data %>% rename(woman = female)
```

## `filter()`

You can also filter out rows that meat or do not meat a certain criteria.

Maybe we are only interested in Members of Congress who are Millenials (born after 1981)

```{r}
congress_data %>% filter(born <= 1981)
```

## `select()`

You can also subset to certain columns using the `select()` command.

Let's only keep a Member of Congress's name, birthyear, and first-dimension DW-NOMINATE score (a commonly used measure of ideology.)

```{r}
congress_data %>% select(name, born, dwnom1)
```

## The Pipe `%>%`

We can chain together commands using the `%>%` function.

For example, we can write the above code as:

```{r}
congress_data %>% filter(born >= 1981) %>%
  select(name, born, dwnom1)
```

::: callout-tip
## Different pipes

You may also see the pipe written as `|>` for R's build-in function. Both are essentially equivalent.
:::

## `mutate()`

We can change or create new variables using the `mutate()` function.

We can create new variables that are transformations of existing variables.

For example, we can create a variable for a legislator's age as the difference between their birth year and the current year:

```{r}
congress_data <- congress_data %>%
  mutate(age = year - born)

congress_data %>% select(born, year, age)
```

## `mutate()`

We can change or create new variables using the `mutate()` function.

We can create new variables using an `ifelse()` statement.

For example, maybe we want to create a new categorical variable for gender.

```{r}
congress_data <- congress_data %>%
  mutate(gender_binary = if_else(female == 1, "Female", "Male"))

congress_data %>% select(female, gender_binary)
```

## `mutate()`

If you have more than one category, `ifelse()` can become unwieldy. This is a great use for the `case_when()` function.

For example, maybe we want to create a new categorical variable for race.

```{r}
congress_data <- congress_data %>%
  mutate(race = case_when(
black == 1 ~ "Black",
latino == 1 ~ "Latino",
aapi == 1 ~ "Asian",
TRUE ~ "White"
))
```

::: callout-warning
## Dangers of `ifelse()` and `case_when()`

Who else gets coded as "White" here?
:::

## `mutate()`

We can mutate several variables together in the same function by placing a comma after each line:

```{r}
congress_data <- congress_data %>%
  mutate(age = year - born,
         gender_binary = if_else(female == 1, "Female", "Male"),
         race = case_when(
           black == 1 ~ "Black",
           latino == 1 ~ "Latino",
           aapi == 1 ~ "Asian",
           TRUE ~ "White"
           ))

congress_data %>% select(age, gender_binary, race)
```

## Summaries by group

You can create summaries of different variables using the `summarize()` function.

```{r}
congress_data %>% summarize(average_effectiveness = mean(les, na.rm=T))
```

Summaries are most useful when combined with `group_by()` which divides the sample into different groups and then performs subgroup analysis.

```{r}
congress_data %>%
  group_by(majority) %>%
  summarize(number_of_respondents = n(),
            average_effectiveness = mean(les, na.rm=T))
```

## Summaries by group

We can also create summaries with multiple groups.

```{r}
congress_data %>%
  group_by(majority, female) %>%
  summarize(number_of_respondents = n(),
            average_effectiveness = mean(les, na.rm=T))
```

::: callout-warning
## Summaries

If you overwrite your original dataset, `summarize()` will reduce the dimensions of your dataset to only what you include.
:::

# 10 Minute Break

## Tidying Data

-   Let's go over how to tidy data that isn't immediately ready to use.

```{r}
untidy_election_data <- read_csv(here::here("inst", "untidy_election_data.csv"))

head(untidy_election_data)
```

-   Each row or observation of `untidy_election_data` is a Member of Congress.

## Data Structure

::: callout-important
-   In wide data, each row is an observation, and each variable is a column. Observations should not be repeated.\
-   In long data, values often repeat across rows, and data is stored in a more compact, stacked format. One column identifies the unit (e.g., `state`), another specifies the variable name (e.g., `variable`), and a third holds the corresponding value.
:::

## `pivot_long()`

::::: columns
::: column
-   Let's take that data and pivot it longer.

```{r}

long_data <- untidy_election_data %>%
 select(!name) %>%
 pivot_longer(cols = starts_with(c("presidentialvoteshare", "contributions")))
long_data
```
:::

::: column
-   Then, we'll separate out the names of the columns into a variable.

```{r}
long_data <- separate(long_data,
                      col = "name",
                      into = c("var", "year"))
long_data
```
:::
:::::

## `pivot_wide()`

-   Here, we do the opposite and take a key column, a value column and make each key a column of its own

```{r}
clean_election_data <- pivot_wider(long_data,
                                   names_from = "var",
                                   values_from = "value")
clean_election_data
```

# Merging Data

## Matching Keys

-   When we merge data, we want the keys to match and for R to treat values appropriately

```{r}

clean_election_data$year <- as.numeric(clean_election_data$year) # Tell R to treat year as a numeric variable.
clean_election_data <- clean_election_data %>%
 mutate(year = year + 1) %>%
 rename(icpsr = ICPSR2) # Make sure the names match. 

```

## Example

-   We use the dyplr function `join` to merge the data now

```{r}
congress_data <- left_join(congress_data, clean_election_data, by = c("icpsr", "year"))
```

## Principles of Merging

-   There are two types of joins:
 1.  Mutating joins, which create new variables based on matching rows or observations.
 2.  Filtering joins that filter out data.

::: callout-tip
There are several different types of joins that all have their uses. When using filtering joins, we highly recommend using `left_join()`. You have the data you are starting with on the left-hand side, and you are adding columns to it from another data set on the right-hand side.
:::

## Messy Example

-   Let's take a messy example and walk through it together
-   Suppose we want to answer a question about the relationship between intrastate conflict and economics, and we have one dataset for each variable.

```{r}
#| output: false

library(pacman)

## A useful function for loading and updating packages. 
pacman::p_load(
 tidyverse,
 peacesciencer, ## IR friends...you will love this package
 lubridate ## needed for fixing dates
)
```

## Create Data

-   We'll use the package we loaded to create data

```{r}
war <- create_stateyears(system = "cow") %>% 
 add_cow_wars(type = "intra", intratype = "all")
 ## always inspect the name of your variables

#colnames(war)


econ <- create_stateyears(system = "cow") %>% 
 add_sim_gdp_pop()

#colnames(econ) 
```

## Merge Data

-   After examining the column names, we join them together and examine the data
-   Our dependent variable is on the left-hand side, and we add economic data to it.
-   Because the key variables are named the same, I did not need to specify the join keys.
    -   Rename before you join!

```{r}
data <- left_join(war, econ)

## Always look at your data, here we select the variables we want and filter out where there was no intrastate war
data %>% 
  filter(!is.na(wartype)) %>% 
 select(cw_name, year, wartype,sd_pwtrgdp) %>% 
  head(10)
```